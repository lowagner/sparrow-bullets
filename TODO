PRIORITY


BaseObject:
methods to figure out:
    hit fraction with other objects.
    
    need an "explode" method.
        sets a timer, sends out sparks (spLine)

    need a "jump" method.


write a CubeModel class.  initialized with 
mesh and texture.  inherits from Cube.



POSSIBLY FIXED BUGS

time update.  slower when program is full screen, but the physics
should happen about the same rate (even if the physics changes a bit)
 -- possibly fixed this in physics.update function.  more testing.

SEGFAULT after exiting program.
    related to not freeing the surface texture?
  doesn't seem to be the problem.
  see if it's not removing the colshape of the box from that physics part.
 -- FIXED??


LESS IMPORTANT STUFF.  REALLY BORING, ACTUALLY

player moving around, getting input
NEED TO KNOW how much contact the player has with the ground.
let that factor into how well he can navigate.

ALso about collisions:
Need to know if player hit his head or landed on his feet.

check out "HitFraction"
btScalar btCollisionObject::getHitFraction  (       )    const



Unordered other things.


Physics World
add_observer_box // some box which will send a signal to whatever method when something collides with it
                 // given some point in space (which can be updated), and some size.



player jump - if in contact with ground, allow for mostly vertical force.



Player Physics:

useful methods of bullet physics classes.

determine orientation of player and what face (top, side, bottom) hit the other point.



Need to somehow cancel out momentum in whatever direction the player is traveling,

//btVector3 correctedImpulse = -mass*boxRigidBody->getLinearVelocity();
//boxRigidBody->applyCentralImpulse(correctedImpulse);

and then add a force which pushes them in the direction in which the player faces.

//btVector3 relativeForce = btVector3(Xforce,Yforce,Zforce); // force in body frame
//btMatrix3x3& boxRot = boxRigidBody->getWorldTransform().getBasis();
//btVector3 correctedForce = boxRot * relativeForce;
//boxRigidBody->applyCentralForce(correctedForce);

For the above:
maybe correct for how much contact the player has with the ground.  
full contact = coefficient = 1 for the above.
partial contact = coefficient < 1.

also can use the above to apply a jump force.

When player changes direction, let camera transition smoothly from where it is to
where the player's next direction is.

// collision mechanics, even with "ghost" particles
http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Collision_Callbacks_and_Triggers

Move a box by fiat:

NOTE:
DOESN'T SEEM TO WORK. only works for static "objects" (mass=0) not dynamic.
will need to delete and recreate dynamic objects.
    btTransform transform;
    rigidBody->getMotionState()->getWorldTransform(transform);
    transform.setOrigin(btVector3(X, Y, Z));  // or whatever
    rigidBody->getMotionState()->setWorldTransform(transform);
    rigidBody->setCenterOfMassTransform(transform);

Can also setRotation instead of setOrigin

get origin:

btTransform transform;
rigidBody->getMotionState()->getWorldTransform(transform);
btVector3 origin = transform.getOrigin();
btQuaternion rot = transform.getRotation();




// some guy's commentary on how to get collisions

someBody->setCollisionFlags(someBody->getCollisionFlags() |
btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK);
someOtherBody->setCollisionFlags(someOtherBody->getCollisionFlags() |
btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK);
gContactProcessedCallback = (ContactProcessedCallback)HandleContacts;


and in your implementation file declar the extern bullet funct 
Code:
extern ContactProcessedCallback gContactProcessedCallback;


In your class implement the ContactProcessedCallback as a static private c++ function
Code:
static bool HandleContacts(btManifoldPoint& point, btCollisionObject* body0, btCollisionObject* body1);
//typedef bool (*ContactProcessedCallback)(
//    btManifoldPoint& cp,
//        void* body0,void* body1);
// point->m_appliedImpulse (scalar)



For which an implementation could vary. The bad thing about this ContactProcessed callback is that bullet seems to call it a random number of times for each collision... not good for sound effects or special effects. So Here is a gift, HandleContacts that enters the collision handling only if enough time has passed between calls. 
Code:
static struct timeval start, end;
bool veryFirst = true;
bool first = true;
bool CShell::HandleContacts(btManifoldPoint& point, btCollisionObject* body0, btCollisionObject* body1) {
btRigidBody* rigidbody0 = dynamic_cast<btRigidBody*>(body0);
btRigidBody* rigidbody1 = dynamic_cast<btRigidBody*>(body1);


float timeThreshold = 350;

float passedTime = 0;
if ( first){
first = false;
if (veryFirst){
veryFirst = false;
passedTime = timeThreshold;
}
gettimeofday(&start, NULL);
}
else {
long mtime, seconds, useconds;  
gettimeofday(&end, NULL);
seconds  = end.tv_sec  - start.tv_sec;
useconds = end.tv_usec - start.tv_usec;

mtime = ((seconds) * 1000 + useconds/1000.0) + 0.5;
passedTime = mtime;

if (passedTime >= timeThreshold)
first = true;
}
// ignore calls until enough time has passed. 
if (passedTime >= timeThreshold)
if(rigidbody0 && rigidbody1){
//NSLog(@"past time: %f",passedTime);
// here you handle your globalBody & otherGlobalBody sound effect or what not derpa
if ((rigidbody0==globalBody && rigidbody1 == otherGlobalBody) ||(rigidbody1==otherGlobalBody && rigidbody0 == globalBody))
{

playRandomBounceSfxFromList();
return true;
}
else {
return false;
}
}   
}

return false;

}
